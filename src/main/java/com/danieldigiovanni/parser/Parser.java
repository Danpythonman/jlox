package com.danieldigiovanni.parser;

import com.danieldigiovanni.expr.Binary;
import com.danieldigiovanni.expr.Expr;
import com.danieldigiovanni.expr.Grouping;
import com.danieldigiovanni.expr.Literal;
import com.danieldigiovanni.expr.Unary;
import com.danieldigiovanni.parser.exception.EmptyTokenListParseException;
import com.danieldigiovanni.parser.exception.LoxParseException;
import com.danieldigiovanni.parser.exception.MissingRightParenParseException;
import com.danieldigiovanni.parser.exception.NoRuleFoundParseException;
import com.danieldigiovanni.parser.exception.UnknownParseException;
import com.danieldigiovanni.token.Token;
import com.danieldigiovanni.token.TokenType;

import java.util.ArrayList;
import java.util.List;

public class Parser {

    /**
     * The list of tokens to be parsed.
     */
    private final List<Token> tokens;

    /**
     * The list of parse exceptions thrown during parsing.
     */
    private final List<LoxParseException> parseExceptions = new ArrayList<>();

    /**
     * The current index (of the list of tokens) being parsed.
     */
    private int current = 0;

    /**
     * The token that was most recently consumed by the parser.
     */
    private Token justConsumed = null;

    /**
     * Initialize a parser with a list of tokens.
     * <p>
     * The list of tokens should be generated by the
     * {@link com.danieldigiovanni.lexer.Lexer} class.
     *
     * @param tokens The list of tokens to be parsed.
     */
    public Parser(List<Token> tokens) {
        this.tokens = tokens;
    }

    /**
     * Parses the list of tokens into an abstract syntax tree.
     *
     * @return The abstract syntax tree corresponding to the list of tokens.
     */
    public Expr parse() {
        try {
            return this.expression();
        } catch (LoxParseException parseException) {
            this.parseExceptions.add(parseException);
            throw parseException;
        }
    }

    /**
     * Expression rule.
     * <p>
     * The expression rule is:
     *
     * <pre>{@code
     * expression -> equality
     * }</pre>
     *
     * which means we just check for the equality rule.
     *
     * @return The expression corresponding to the given list of tokens.
     */
    private Expr expression() {
        return this.equality();
    }

    /**
     * Equality rule.
     * <p>
     * The equality rule is:
     *
     * <pre>{@code
     * equality -> comparison ( ( "!=" | "==" ) comparison )*
     * }</pre>
     *
     * which means we check for the comparison rule, followed by zero or more
     * equalities or inequalities with another comparison.
     *
     * @return The expression representing the equality rule.
     */
    private Expr equality() {
        Expr expr = this.comparison();
        Expr left = expr;

        while (this.matchTokenType(TokenType.EQUAL_EQUAL, TokenType.BANG_EQUAL)) {
            Token operator = this.consume();
            Expr right = this.comparison();
            expr = new Binary(left, operator, right);
        }

        return expr;
    }

    /**
     * Comparison rule.
     * <p>
     * The comparison rule is:
     *
     * <pre>{@code
     * comparison -> term ( ( ">" | ">=" | "<" | "<=" ) term )*
     * }</pre>
     *
     * which means we check for the term rule, followed by zero or more
     * comparison operators with another term.
     *
     * @return The expression representing the comparison rule.
     */
    private Expr comparison() {
        Expr expr = this.term();
        Expr left = expr;

        while (this.matchTokenType(
            TokenType.GREATER,
            TokenType.GREATER_EQUAL,
            TokenType.LESS,
            TokenType.LESS_EQUAL
        )) {
            Token operator = this.consume();
            Expr right = this.term();
            expr = new Binary(left, operator, right);
        }

        return expr;
    }

    /**
     * Term rule.
     * <p>
     * The term rule is:
     *
     * <pre>{@code
     * term -> factor ( ( "-" | "+" ) factor )*
     * }</pre>
     *
     * which means we check for the factor rule, followed by zero or more
     * addition or subtraction operators with another factor.
     *
     * @return The expression representing the term rule.
     */
    private Expr term() {
        Expr expr = this.factor();
        Expr left = expr;

        while (this.matchTokenType(TokenType.PLUS, TokenType.MINUS)) {
            Token operator = this.consume();
            Expr right = this.factor();
            expr = new Binary(left, operator, right);
        }

        return expr;
    }

    /**
     * Factor rule.
     * <p>
     * The factor rule is:
     *
     * <pre>{@code
     * factor -> unary ( ( "*" | "/" ) unary )*
     * }</pre>
     *
     * which means we check for the unary rule, followed by zero or more
     * multiplication or division operators with another unary.
     *
     * @return The expression representing the factor rule.
     */
    private Expr factor() {
        Expr expr = this.unary();
        Expr left = expr;

        while (this.matchTokenType(TokenType.STAR, TokenType.SLASH)) {
            Token operator = this.consume();
            Expr right = this.unary();
            expr = new Binary(left, operator, right);
        }

        return expr;
    }

    /**
     * Unary rule.
     * <p>
     * The unary rule is:
     *
     * <pre>{@code
     * unary -> ( ( "!" | "-" ) unary ) | primary
     * }</pre>
     *
     * which means we check for either one of:
     * <ul>
     *     <li>a bang or minus operator followed by a unary expression, or</li>
     *     <li>a primary expression.</li>
     * </ul>
     *
     * @return The expression representing the unary rule.
     */
    private Expr unary() {
        if (this.matchTokenType(TokenType.BANG, TokenType.MINUS)) {
            Token operator = this.consume();
            Expr expr = this.unary();
            return new Unary(operator, expr);
        }

        return this.primary();
    }

    /**
     * Primary rule.
     * <p>
     * The primary rule is:
     *
     * <pre>{@code
     * primary -> NUMBER | STRING | "true" | "false" | "nil" | "(" expression ")"
     * }</pre>
     *
     * which means we check for either one of:
     * <ul>
     *     <li>a numeric literal, or</li>
     *     <li>a string literal, or</li>
     *     <li>the literal {@code true}, or</li>
     *     <li>the literal {@code false}, or</li>
     *     <li>the literal {@code nil}, or</li>
     *     <li>an expression surrounded by parentheses.</li>
     * </ul>
     *
     * @return The expression representing the primary rule.
     */
    private Expr primary() {
        if (this.matchTokenType(TokenType.TRUE)) {
            this.consume();
            return new Literal(true);
        }
        if (this.matchTokenType(TokenType.FALSE)) {
            this.consume();
            return new Literal(false);
        }
        if (this.matchTokenType(TokenType.NIL)) {
            this.consume();
            return new Literal(null);
        }
        if (this.matchTokenType(TokenType.NUMBER, TokenType.STRING)) {
            Literal literal = new Literal(this.peek().getLiteral());
            this.consume();
            return literal;
        }
        if (this.matchTokenType(TokenType.LEFT_PAREN)) {
            // Consume left parenthesis
            this.consume();
            // Parse expression
            Expr expr = this.expression();
            // After parsing the left parenthesis and expression, if we do not
            // find the right parenthesis then this is an error.
            if (!this.peek().getType().equals(TokenType.RIGHT_PAREN)) {
                throw new MissingRightParenParseException(this.errorSource());
            }
            // Consume right paren
            this.consume();
            // Return grouped expression
            return new Grouping(expr);
        }

        /*
         * If this point is reached, then no rule was found that could parse
         * the statement.
         */
        throw new NoRuleFoundParseException(this.errorSource());
    }

    /**
     * Checks if the current token being parsed matches any of the given token
     * types.
     *
     * @param tokenTypes The list of token types to be matched.
     *
     * @return {@code true} if the current token being parsed has the same type
     *         as any of the given token types, {@code false} otherwise.
     */
    private boolean matchTokenType(TokenType... tokenTypes) {
        for (TokenType tokenType : tokenTypes) {
            if (this.peek().getType().equals(tokenType)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the current token being parsed and increments the parser to the
     * next token.
     *
     * @return The current token being parsed.
     */
    private Token consume() {
        Token token = this.peek();
        this.current++;
        this.justConsumed = token;
        return token;
    }

    /**
     * Gets the current token being parsed.
     *
     * @return The current token being parsed.
     */
    private Token peek() {
        return this.tokens.get(this.current);
    }

    private Token errorSource() {
        if (this.justConsumed != null) {
            return this.justConsumed;
        }
        if (this.peek() != null) {
            return this.peek();
        }
        if (this.tokens.isEmpty()) {
            throw new EmptyTokenListParseException();
        }
        throw new UnknownParseException();
    }

    /**
     * Discards all tokens from the current token being parsed until a new
     * statement is reached.
     * <p>
     * This means that either
     *
     * <ul>
     *     <li>
     *         a semicolon token or an EOF token is encountered, in which case
     *         the token are consumed and this method returns, or
     *     </li>
     *     <li>
     *         a token corresponding to the beginning of a statement is
     *         encountered, in which case this method returns without consuming
     *         that token.
     *         <p>
     *         The tokens corresponding to the beginning of a statement are:
     *         <ul>
     *             <li>{@code class}</li>
     *             <li>{@code fun}</li>
     *             <li>{@code var}</li>
     *             <li>{@code if}</li>
     *             <li>{@code for}</li>
     *             <li>{@code while}</li>
     *             <li>{@code print}</li>
     *             <li>{@code return}</li>
     *         </ul>
     *     </li>
     * </ul>
     *
     * The reason we continue to parse the next statement after synchronizing
     * is because we want to report as many syntax errors as possible without
     * reporting many errors from a single statement.
     * <p>
     * Note that tokens are discarded by incrementing the parser past them
     * without actually using those tokens.
     */
    private void synchronize() {
        Token currentToken = this.peek();
        while (!currentToken.getType().equals(TokenType.EOF)) {
            if (currentToken.getType().equals(TokenType.SEMICOLON)) {
                this.consume();
                return;
            }

            switch (currentToken.getType()) {
                case CLASS:
                case FUN:
                case VAR:
                case IF:
                case FOR:
                case WHILE:
                case PRINT:
                case RETURN:
                    return;
            }

            this.consume();
            currentToken = this.peek();
        }
    }

}
